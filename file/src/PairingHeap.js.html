<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/PairingHeap.js | aureooms/js-pairing-heap</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-style.css"><script src="./inject/script/0-header.js"></script><meta name="description" content="Pairing heap data structure library for JavaScript"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="aureooms/js-pairing-heap"><meta property="twitter:description" content="Pairing heap data structure library for JavaScript"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/aureooms/js-pairing-heap"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Node.js~Beginning.html">Beginning</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Node.js~Node.html">Node</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PairingHeap.js~PairingHeap.html">PairingHeap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-decreasekey">decreasekey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-merge">merge</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mergepairs">mergepairs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-prepend">prepend</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/PairingHeap.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import merge from &apos;./merge&apos; ;
import mergepairs from &apos;./mergepairs&apos; ;
import decreasekey from &apos;./decreasekey&apos; ;
import Node from &apos;./Node&apos; ;

export default class PairingHeap {

	constructor (compare) {
		this.compare = compare ; // comparison function
		this.min = null ;        // root node, must have .prev = .next = null at all times
	}

	/**
	 * find-min: simply return the top element of the heap.
	 */
	head () {
		if ( this.min === null ) return undefined;
		return this.min.value;
	}


	headreference () {
		return this.min;
	}

	/**
	 * delete-min: remove the root and merge its subtrees. Various strategies
	 * are employed.
	 */
	pop () {
		const min = this.popreference();
		return min === null ? undefined : min.value ;
	}

	/**
	 */
	popreference () {
		if (this.min === null ) return null;
		const min = this.min;
		this.min = mergepairs(this.compare, min.children); // min.children.next = null
		return min;
	}

	/**
	 * insert: create a new heap for the inserted element and merge into the
	 * original heap.
	 */
	push ( value ) {
		const node = new Node(value) ;
		return this.pushreference(node);
	}

	/**
	 * /!\ ref.next = ref.prev = null which means all references that are
	 * external to the tree must reset .next and .prev and one must not call
	 * PairingHeap#pushreference with an internal reference from this tree or
	 * another, except the root of another tree.
	 */
	pushreference ( ref ) {
		if (this.min === null) this.min = ref;
		else {
			// this.min != null != ref
			this.min = merge( this.compare , this.min , ref ) ;
		}
		return ref;
	}


	/**
	 * Supposes the same comparison function is used in both trees.
	 * We can call pushreference since other.min.next = other.min.prev = null.
	 */
	merge ( other ) {
		const ref = other.min ;
		if (ref !== null) this.pushreference( ref ) ;
	}


	/**
	 * @param {Node} ref Non-null internal node object.
	 * @param {Object} value The new value for ref.
	 */
	update ( ref , value ) {

		const d = this.compare(value, ref.value) ;

		if      ( d &lt; 0 ) this.decreasekey(ref, value) ;
		else if ( d &gt; 0 ) this.increasekey(ref, value) ;
		else              ref.value = value ;

	}

	/**
	 * @param {Node} ref Non-null internal node object.
	 * @param {Object} value The new value for ref.
	 */
	decreasekey ( ref , value ) {
		if (ref === this.min) ref.value = value ;
		else {
			// this.min != null, ref != null
			this.min = decreasekey( this.compare , this.min , ref , value ) ;
		}
	}

	/**
	 * increase-key: remove the item at the key to be decreased, replace
	 * the key with a smaller key, then merge the result back into the heap.
	 *
	 * @param {Node} ref Non-null internal node object.
	 * @param {Object} value The new value for ref.
	 *
	 */
	increasekey ( ref , value ) {

		this.delete(ref);

		ref.value = value;

		this.pushreference( ref ) ;

	}

	/**
	 * ref must be internal
	 * ref.prev and ref.next get reset to null
	 */
	delete ( ref ) {

		if ( ref === this.min ) {
			this.popreference() ;
			return ;
		}

		const successor = mergepairs(this.compare, ref.children); // ref.children.next = null

		// ref has no children
		if (successor === null) {

			//  _       _       _
			// | | --&gt; | | --&gt; | |
			// |_| &lt;-- |_| &lt;-- |_|
			//  P       R       N

			// detach ref and link ref.prev to ref.next
			//
			//  _               _
			// | | ----------&gt; | |
			// |_| &lt;    _   -&gt; |_|
			//  P   \  | | /  / N
			//       - |_| &lt;-/
			//          R
			//
			ref.prev.next = ref.next ; // must be != null because ref != min

			if (ref.next !== null) {
				//
				//  _               _
				// | | ----------&gt; | |
				// |_| &lt;---------- |_|
				//  P       _       N
				//  ^      | | -----^
				//  |----- |_|
				//          R
				//
				ref.next.prev = ref.prev ;
				//
				//  _               _
				// | | ----------&gt; | |
				// |_| &lt;---------- |_|
				//  P       _       N
				//  ^      | |
				//  |----- |_|
				//          R
				//
				ref.next = null;
			}

			//
			//  _               _
			// | | ----------&gt; | |
			// |_| &lt;---------- |_|
			//  P       _       N
			//         | |
			//         |_|
			//          R
			//
			ref.prev = null;

			return;

		}

		successor.prev = ref.prev ; // must be != null because ref != min
		successor.prev.next = successor ;
		ref.prev = null;

		if (ref.next !== null) {
			successor.next = ref.next ; // might be null
			successor.next.prev = successor ;
			ref.next = null;
		}

	}


}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
